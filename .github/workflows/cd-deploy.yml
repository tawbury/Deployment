# CD workflow: deploy Observer to VM via declarative spec (infra/_shared/deploy/observer.yaml).
# Kubernetes-like architecture: detect new GHCR images and deploy automatically.
# Triggers: schedule (poll GHCR every 5 min) or workflow_dispatch (manual override).
# Designed for future replacement by kubectl apply.

name: CD Deploy

on:
  schedule:
    # Check GHCR for new images every day at 21:00 KST (12:00 UTC)
    - cron: '0 12 * * *'
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g. build-20260128-123456). Leave empty to use latest."
        required: false
        default: ""
      environment:
        description: "Target environment (OCI01, OCI02, ARM01, AWS01, etc.)"
        required: false
        default: "OCI01"
      skip_health:
        description: "Skip post-deploy health check"
        required: false
        type: boolean
        default: false
      force_deploy:
        description: "Force deploy even if image hasn't changed"
        required: false
        type: boolean
        default: false

env:
  DEPLOY_SPEC: infra/_shared/deploy/observer.yaml

jobs:
  check-new-image:
    name: Check for new GHCR image
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}
      target_env: ${{ steps.check.outputs.target_env }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check GHCR for new image
        id: check
        env:
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Manual override: always deploy with specified tag
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.image_tag }}" ]; then
              TAG="${{ github.event.inputs.image_tag }}"
            else
              TAG="latest"
            fi
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
            echo "image_tag=$TAG" >> "$GITHUB_OUTPUT"
            echo "target_env=${{ github.event.inputs.environment || 'OCI01' }}" >> "$GITHUB_OUTPUT"
            echo "Manual deploy requested: $TAG to ${{ github.event.inputs.environment || 'OCI01' }}"
            exit 0
          fi

          # Scheduled check: query GHCR API for latest tag
          OWNER="tawbury"
          PACKAGE="observer"
          
          # Get latest tag (excluding 'latest' itself)
          LATEST_TAG=$(curl -s -H "Authorization: Bearer $GHCR_TOKEN" \
            "https://api.github.com/users/$OWNER/packages/container/$PACKAGE/versions" \
            | jq -r '[.[] | select(.metadata.container.tags[] | select(. != "latest"))] | .[0].metadata.container.tags[] | select(startswith("build-"))' \
            | head -1)

          if [ -z "$LATEST_TAG" ]; then
            echo "No build tags found in GHCR, skipping deployment"
            echo "should_deploy=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Latest GHCR tag: $LATEST_TAG"

          # Check if this tag was already deployed
          LAST_DEPLOYED_FILE=".github/last_deployed_tag"
          if [ -f "$LAST_DEPLOYED_FILE" ]; then
            LAST_DEPLOYED=$(cat "$LAST_DEPLOYED_FILE")
          else
            LAST_DEPLOYED=""
          fi

          if [ "$LATEST_TAG" = "$LAST_DEPLOYED" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            echo "Image $LATEST_TAG already deployed, skipping"
            echo "should_deploy=false" >> "$GITHUB_OUTPUT"
          else
            echo "New image detected: $LATEST_TAG (was: $LAST_DEPLOYED)"
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
            echo "image_tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"
            echo "target_env=OCI01" >> "$GITHUB_OUTPUT"
          fi

  deploy:
    name: Deploy to VM
    runs-on: ubuntu-latest
    needs: check-new-image
    if: needs.check-new-image.outputs.should_deploy == 'true'
    # Use GitHub Environment for environment-specific secrets
    environment: ${{ needs.check-new-image.outputs.target_env }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy via SSH
        env:
          DEPLOY_SPEC: ${{ env.DEPLOY_SPEC }}
          IMAGE_TAG: ${{ needs.check-new-image.outputs.image_tag }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_KEY: ${{ secrets.SSH_KEY }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          DEPLOY_DIR: ${{ secrets.DEPLOY_DIR }}
          ENV_FILE_PATH: /home/ubuntu/observer/secrets/.env
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          chmod +x infra/_shared/scripts/deploy/deploy.sh
          ./infra/_shared/scripts/deploy/deploy.sh
        # ENV_FILE_PATH: remote .env for docker --env-file. Fixed to server path.

      - name: Record deployed tag
        if: success()
        run: |
          mkdir -p .github
          echo "${{ needs.check-new-image.outputs.image_tag }}" > .github/last_deployed_tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/last_deployed_tag
          git commit -m "chore: record deployed tag ${{ needs.check-new-image.outputs.image_tag }}" || true
          git push || true

      - name: Post-deploy health check (optional)
        if: success() && github.event.inputs.skip_health != 'true'
        run: |
          echo "Health check is performed inside deploy.sh on the remote host."
          echo "For external checks, configure a job that curls your public endpoint."
